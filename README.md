# story-song

Маркетинговый лендинг для заказа персональных песен.

## Деплой через Docker Compose

Стек состоит из трёх контейнеров: PHP-FPM (PHP 8.3) с приложением, Nginx в роли фронтенд-сервера и Certbot, который выпускает и продлевает бесплатные SSL-сертификаты Let's Encrypt.

### Требования

- Docker Engine 20.10+
- Docker Compose plugin 2.0+
- Домен, указывающий на сервер, где разворачивается приложение

### Настройка окружения

1. Скопируйте файл `.env.example` в `.env` и укажите боевые значения:

   ```bash
   cp .env.example .env
   ```

2. Обновите переменные в `.env`:

   - `DOMAIN` — ваш домен (например, `music.example.com`).
   - `EMAIL` — контактная почта для уведомлений Let's Encrypt.
   - При необходимости добавьте токены `TELEGRAM_BOT_TOKEN` и `TELEGRAM_CHAT_ID`, чтобы форма отправляла заявки в Telegram.
   - Укажите `IPDATA_API_KEY`, чтобы геолокация IP работала через сервис [ipdata.co](https://ipdata.co/).

### Запуск

1. Выполните скрипт деплоя:

   ```bash
   ./deploy.sh
   ```

   Скрипт проверит `.env`, соберёт образ PHP-приложения и запустит контейнеры `php` и `nginx`.

   > Если после обновления репозитория менялись файлы `deploy.sh`, шаблоны Nginx или конфигурация Docker, просто запустите `./deploy.sh` ещё раз. Скрипт идемпотентный: он пересоберёт образы при необходимости, подкопирует вспомогательные файлы TLS и перезагрузит Nginx с актуальной конфигурацией.

2. Если сертификата ещё нет, скрипт автоматически запросит его через Certbot по HTTP-челленджу, обновит конфигурацию Nginx и перезапустит сервер.

3. После успешного выпуска сертификата будет запущен контейнер `certbot-renew`, который каждые 12 часов проверяет необходимость продления. Nginx отслеживает изменения файлов в каталоге сертификатов, обновляет конфигурацию и выполняет graceful reload, поэтому новые ключи начинают использоваться без перезапуска стека, а после первого выпуска TLS включается автоматически.

### Полезные команды

- Перезапустить стек после обновления кода:

  ```bash
  docker compose up -d --build php nginx
  ```

- Запустить сервис продления сертификатов вручную (например, после остановки):

  ```bash
  docker compose up -d certbot-renew
  ```

- Просмотреть логи Nginx, PHP или Certbot:

  ```bash
  docker compose logs -f nginx
  docker compose logs -f php
   docker compose logs -f certbot-renew
  ```

- Остановить и удалить контейнеры:

  ```bash
  docker compose down
  ```

## Работа с базой данных и заявками

Приложение использует Doctrine ORM и по умолчанию сохраняет заявки в базу SQLite (`var/data/story-song.sqlite`). Конфигурация собрана в файле `config/doctrine.php`, поэтому при необходимости её легко заменить на PostgreSQL, MySQL или другой драйвер Doctrine через переменную окружения `DATABASE_URL`.

Каталог `var/data` примонтирован в контейнеры как отдельный volume, поэтому файл SQLite хранится на хосте и переживает пересборку образов. Скрипт `deploy.sh` автоматически создаёт каталог при деплое, а для локальной разработки его можно подготовить вручную командой `mkdir -p var/data`.

- Применить миграции (создать или обновить схему базы данных):

  ```bash
  php bin/console doctrine:migrations:migrate
  ```

- Отправить несинхронизированные заявки в Telegram (подходит для запуска по cron):

  ```bash
  php bin/console app:dispatch-song-requests
  ```

  Команда отмечает успешно отправленные заявки в таблице `telegram_dispatches`, поэтому повторные запуски не дублируют сообщения. Её можно вызвать напрямую из cron, например: `*/5 * * * * cd /path/to/app && php bin/console app:dispatch-song-requests` (не забудьте экспортировать `TELEGRAM_BOT_TOKEN` и `TELEGRAM_CHAT_ID`).

  В продакшн- и локальном `docker-compose` добавлен сервис `cron`, который по умолчанию раз в пять минут запускает эту команду внутри отдельного контейнера. Расписание и сами задания задаются в файле `docker/common/cron/app.cron`, который примонтирован в контейнер вместе с кодом. Отредактируйте его и перезапустите сервис, чтобы cron подхватил изменения. Контейнер разделяет volume `var/data`, поэтому использует ту же базу SQLite.

### Админ-панель EasyAdmin

- Админка доступна по адресу `/admin` и защищена аутентификацией.
- Перед первым входом создайте пользователя с помощью консольной команды:

  ```bash
  php bin/console app:create-admin --email=you@example.com
  ```

  Если пароль не передан в параметрах, команда запросит его интерактивно.
- После логина доступны CRUD-страницы заявок и администраторов. Чтобы выйти, используйте пункт меню «Выйти».

## Локальный запуск для разработки

### Через Docker Compose

1. Скопируйте переменные окружения:

   ```bash
   cp .env.example .env
   ```

2. Соберите и запустите локальный стек (GeoIP API + PHP-FPM + cron + Nginx):

   ```bash
   docker compose -f docker-compose.local.yml up --build
   ```

   Сервис GeoIP будет доступен на [http://localhost:8044](http://localhost:8044) для ручной проверки, а приложение обращается к
   нему по внутреннему имени `geoip`.

3. Установите зависимости внутри контейнера (однократно):

   ```bash
   docker compose -f docker-compose.local.yml exec app composer install
   ```

   > Репозиторий принудительно ставит пакет `slim/psr7` из исходников, чтобы обойти сбой распаковки архива на некоторых файловых системах. Убедитесь, что в контейнере доступен `git` (он уже установлен в образе `app`).

4. Откройте [http://localhost:8080](http://localhost:8080) — лендинг будет доступен через Nginx, а изменения в коде подхватываются благодаря примонтированному каталогу проекта.

### Без Docker

1. Установите зависимости PHP через Composer:

   ```bash
   composer install
   ```

   > Пакет `slim/psr7` будет склонирован из Git, поэтому локальный Composer должен иметь доступ к исполняемому файлу `git`.

2. Запустите встроенный сервер PHP, указав каталог `public` в качестве корня и фронт-контроллер Slim:

   ```bash
   php -S localhost:8000 -t public public/index.php
   ```

3. Откройте [http://localhost:8000](http://localhost:8000) в браузере.
